"use strict";(self.webpackChunkreact_native_website=self.webpackChunkreact_native_website||[]).push([[65962],{35318:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>d});var a=n(27378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(n),d=r,b=m["".concat(s,".").concat(d)]||m[d]||c[d]||o;return n?a.createElement(b,i(i({ref:t},u),{},{components:n})):a.createElement(b,i({ref:t},u))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},11674:(e,t,n)=>{n.d(t,{Z:()=>i});var a=n(63445);const r=!!a.Z.canUseDOM&&navigator.platform.startsWith("Mac"),o=!!a.Z.canUseDOM&&navigator.platform.startsWith("Win"),i={defaultGuide:"native",defaultOs:r?"macos":o?"windows":"linux",defaultPackageManager:"npm",defaultPlatform:r?"ios":"android",defaultSyntax:"functional",getDevNotesTabs:(e=["android","ios","web","windows"])=>[e.includes("android")?{label:"Android",value:"android"}:void 0,e.includes("ios")?{label:"iOS",value:"ios"}:void 0,e.includes("web")?{label:"Web",value:"web"}:void 0,e.includes("windows")?{label:"Windows",value:"windows"}:void 0].filter(Boolean),guides:[{label:"\u5b8c\u6574\u539f\u751f\u73af\u5883",value:"native"},{label:"\u7b80\u6613\u6c99\u76d2\u73af\u5883",value:"quickstart"}],oses:[{label:"macOS",value:"macos"},{label:"Windows",value:"windows"},{label:"Linux",value:"linux"}],packageManagers:[{label:"npm",value:"npm"},{label:"Yarn",value:"yarn"}],platforms:[{label:"Android",value:"android"},{label:"iOS",value:"ios"}],syntax:[{label:"\u51fd\u6570\u5f0f\u7ec4\u4ef6",value:"functional"},{label:"Class \u7ec4\u4ef6",value:"classical"}]}},86386:(e,t,n)=>{n.d(t,{Z:()=>c});var a=n(27378),r=n(38944);const o="tabItem_wHwb";var i=Object.defineProperty,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,u=(e,t,n)=>t in e?i(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;function c({children:e,hidden:t,className:n}){return a.createElement("div",((e,t)=>{for(var n in t||(t={}))s.call(t,n)&&u(e,n,t[n]);if(l)for(var n of l(t))p.call(t,n)&&u(e,n,t[n]);return e})({role:"tabpanel",className:(0,r.Z)(o,n)},{hidden:t}),e)}},27789:(e,t,n)=>{n.d(t,{Z:()=>k});var a=n(27378),r=n(38944),o=n(14185),i=n(27886),l=n(77184),s=n(12112);const p="tabList_J5MA",u="tabItem_l0OV";var c=Object.defineProperty,m=Object.defineProperties,d=Object.getOwnPropertyDescriptors,b=Object.getOwnPropertySymbols,y=Object.prototype.hasOwnProperty,g=Object.prototype.propertyIsEnumerable,v=(e,t,n)=>t in e?c(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,f=(e,t)=>{for(var n in t||(t={}))y.call(t,n)&&v(e,n,t[n]);if(b)for(var n of b(t))g.call(t,n)&&v(e,n,t[n]);return e};function h(e){var t,n;const{lazy:o,block:c,defaultValue:b,values:y,groupId:g,className:v}=e,h=a.Children.map(e.children,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),k=null!=y?y:h.map((({props:{value:e,label:t,attributes:n}})=>({value:e,label:t,attributes:n}))),N=(0,i.l)(k,((e,t)=>e.value===t.value));if(N.length>0)throw new Error(`Docusaurus error: Duplicate values "${N.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const C=null===b?b:null!=(n=null!=b?b:null==(t=h.find((e=>e.props.default)))?void 0:t.props.value)?n:h[0].props.value;if(null!==C&&!k.some((e=>e.value===C)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${C}" but none of its children has the corresponding value. Available values are: ${k.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:w,setTabGroupChoices:S}=(0,l.U)(),[T,O]=(0,a.useState)(C),j=[],{blockElementScrollPositionUntilNextRender:x}=(0,s.o5)();if(null!=g){const e=w[g];null!=e&&e!==T&&k.some((t=>t.value===e))&&O(e)}const M=e=>{const t=e.currentTarget,n=j.indexOf(t),a=k[n].value;a!==T&&(x(t),O(a),null!=g&&S(g,String(a)))},P=e=>{var t,n;let a=null;switch(e.key){case"Enter":M(e);break;case"ArrowRight":{const n=j.indexOf(e.currentTarget)+1;a=null!=(t=j[n])?t:j[0];break}case"ArrowLeft":{const t=j.indexOf(e.currentTarget)-1;a=null!=(n=j[t])?n:j[j.length-1];break}}null==a||a.focus()};return a.createElement("div",{className:(0,r.Z)("tabs-container",p)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":c},v)},k.map((({value:e,label:t,attributes:n})=>{return a.createElement("li",(o=f({role:"tab",tabIndex:T===e?0:-1,"aria-selected":T===e,key:e,ref:e=>j.push(e),onKeyDown:P,onClick:M},n),i={className:(0,r.Z)("tabs__item",u,null==n?void 0:n.className,{"tabs__item--active":T===e})},m(o,d(i))),null!=t?t:e);var o,i}))),o?(0,a.cloneElement)(h.filter((e=>e.props.value===T))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},h.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==T})))))}function k(e){const t=(0,o.Z)();return a.createElement(h,f({key:String(t)},e))}},31043:(e,t,n)=>{n.d(t,{ZP:()=>d});var a=n(35318),r=Object.defineProperty,o=Object.defineProperties,i=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable,u=(e,t,n)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,c=(e,t)=>{for(var n in t||(t={}))s.call(t,n)&&u(e,n,t[n]);if(l)for(var n of l(t))p.call(t,n)&&u(e,n,t[n]);return e};const m={toc:[]};function d(e){var t,n=e,{components:r}=n,u=((e,t)=>{var n={};for(var a in e)s.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&l)for(var a of l(e))t.indexOf(a)<0&&p.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=c(c({},m),u),o(t,i({components:r,mdxType:"MDXLayout"}))),(0,a.kt)("admonition",c({},{type:"caution"}),(0,a.kt)("p",{parentName:"admonition"},"This documentation is still ",(0,a.kt)("strong",{parentName:"p"},"experimental")," and details are subject to changes as we iterate. Feel free to share your feedback on the ",(0,a.kt)("a",c({parentName:"p"},{href:"https://github.com/reactwg/react-native-new-architecture/discussions/8"}),"discussion inside the working group")," for this page."),(0,a.kt)("p",{parentName:"admonition"},"Moreover, it contains several ",(0,a.kt)("strong",{parentName:"p"},"manual steps"),". Please note that this won't be representative of the final developer experience once the New Architecture is stable. We're working on tools, templates and libraries to help you get started fast on the New Architecture, without having to go through the whole setup.")))}d.isMDXComponent=!0},99768:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>v,default:()=>C,frontMatter:()=>g,metadata:()=>f,toc:()=>k});var a=n(35318),r=n(27789),o=n(86386),i=n(11674),l=n(31043),s=Object.defineProperty,p=Object.defineProperties,u=Object.getOwnPropertyDescriptors,c=Object.getOwnPropertySymbols,m=Object.prototype.hasOwnProperty,d=Object.prototype.propertyIsEnumerable,b=(e,t,n)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,y=(e,t)=>{for(var n in t||(t={}))m.call(t,n)&&b(e,n,t[n]);if(c)for(var n of c(t))d.call(t,n)&&b(e,n,t[n]);return e};const g={id:"cxx-custom-types",title:"Supporting Custom C++ Types"},v=void 0,f={unversionedId:"the-new-architecture/cxx-custom-types",id:"version-0.71/the-new-architecture/cxx-custom-types",title:"Supporting Custom C++ Types",description:"By default C++ Turbo Native Modules support bridging functionality for most std:: standard types.",source:"@site/versioned_docs/version-0.71/the-new-architecture/cxx-custom-types.md",sourceDirName:"the-new-architecture",slug:"/the-new-architecture/cxx-custom-types",permalink:"/docs/the-new-architecture/cxx-custom-types",draft:!1,editUrl:"https://github.com/reactnativecn/react-native-website/blob/production/cnwebsite/../cndocs/the-new-architecture/cxx-custom-types.md",tags:[],version:"0.71",frontMatter:{id:"cxx-custom-types",title:"Supporting Custom C++ Types"},sidebar:"docs",previous:{title:"C++ Turbo Native Modules",permalink:"/docs/the-new-architecture/cxx-cxxturbomodules"},next:{title:"\u5411\u540e\u517c\u5bb9\u7684\u610f\u4e49",permalink:"/docs/the-new-architecture/backward-compatibility"}},h={},k=[{value:"Example: Int64",id:"example-int64",level:2},{value:"Any custom type",id:"any-custom-type",level:2},{value:"Custom structs",id:"custom-structs",level:2},{value:"Manually typed",id:"manually-typed",level:3},{value:"Struct generator",id:"struct-generator",level:3},{value:"Member types",id:"member-types",level:4},{value:"Base class",id:"base-class",level:4}],N={toc:k};function C(e){var t,n=e,{components:s}=n,b=((e,t)=>{var n={};for(var a in e)m.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&c)for(var a of c(e))t.indexOf(a)<0&&d.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=y(y({},N),b),p(t,u({components:s,mdxType:"MDXLayout"}))),(0,a.kt)(l.ZP,{mdxType:"NewArchitectureWarning"}),(0,a.kt)("p",null,"By default C++ Turbo Native Modules support ",(0,a.kt)("a",y({parentName:"p"},{href:"https://github.com/facebook/react-native/tree/main/ReactCommon/react/bridging"}),"bridging functionality")," for most ",(0,a.kt)("inlineCode",{parentName:"p"},"std::")," standard types."),(0,a.kt)("p",null,"If you want to add support for new / custom types in your app / library, you only need to provide the necessary ",(0,a.kt)("inlineCode",{parentName:"p"},"bridging")," header file."),(0,a.kt)("p",null,"This guide continues the previous ",(0,a.kt)("a",y({parentName:"p"},{href:"./cxx-cxxturbomodules"}),"C++ Turbo Native Modules")," section."),(0,a.kt)("h2",y({},{id:"example-int64"}),"Example: Int64"),(0,a.kt)("p",null,"C++ Turbo Native Modules don't support ",(0,a.kt)("inlineCode",{parentName:"p"},"int64_t")," numbers yet - because JavaScript doesn't support numbers greater ",(0,a.kt)("inlineCode",{parentName:"p"},"2^53"),"."),(0,a.kt)("p",null,"We can't represent numbers > ",(0,a.kt)("inlineCode",{parentName:"p"},"2^53")," as JavaScript ",(0,a.kt)("inlineCode",{parentName:"p"},"number"),"'s - but we can represent them as JavaScript ",(0,a.kt)("inlineCode",{parentName:"p"},"string"),"'s and automatically convert (aka. ",(0,a.kt)("inlineCode",{parentName:"p"},"bridge"),") them to C++ ",(0,a.kt)("inlineCode",{parentName:"p"},"int64_t"),"'s by creating a custom Bridging header file called ",(0,a.kt)("inlineCode",{parentName:"p"},"Int64.h")," in the ",(0,a.kt)("inlineCode",{parentName:"p"},"tm")," folder:"),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-cpp",metastring:"Int64.h","Int64.h":!0}),'#pragma once\n\n#include <react/bridging/Bridging.h>\n\nnamespace facebook::react {\n\ntemplate <>\nstruct Bridging<int64_t> {\n  static int64_t fromJs(jsi::Runtime &rt, const jsi::String &value) {\n    try {\n      size_t pos;\n      auto str = value.utf8(rt);\n      auto num = std::stoll(str, &pos);\n      if (pos != str.size()) {\n        throw std::invalid_argument("Invalid number"); // don\'t support alphanumeric strings\n      }\n      return num;\n    } catch (const std::logic_error &e) {\n      throw jsi::JSError(rt, e.what());\n    }\n  }\n\n  static jsi::String toJs(jsi::Runtime &rt, int64_t value) {\n    return bridging::toJs(rt, std::to_string(value));\n  }\n};\n\n} // namespace facebook::react\n')),(0,a.kt)("p",null,"The key components for your custom ",(0,a.kt)("inlineCode",{parentName:"p"},"bridging")," header are:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Explicit specialization of the ",(0,a.kt)("inlineCode",{parentName:"li"},"Bridging")," struct for your custom type, ",(0,a.kt)("inlineCode",{parentName:"li"},"int64_t")," in this case"),(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("inlineCode",{parentName:"li"},"fromJs")," function to convert from ",(0,a.kt)("inlineCode",{parentName:"li"},"jsi::")," types to your custom type"),(0,a.kt)("li",{parentName:"ul"},"A ",(0,a.kt)("inlineCode",{parentName:"li"},"toJS")," function to convert from your custom type to ",(0,a.kt)("inlineCode",{parentName:"li"},"jsi:")," types")),(0,a.kt)("p",null,"Omitting either ",(0,a.kt)("inlineCode",{parentName:"p"},"fromJS")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"toJS")," would make you ",(0,a.kt)("inlineCode",{parentName:"p"},"bridging")," header either ",(0,a.kt)("em",{parentName:"p"},"readonly")," or ",(0,a.kt)("em",{parentName:"p"},"writeonly"),"."),(0,a.kt)("p",null,"Now you can add the following function to your JavaScript spec:"),(0,a.kt)(r.Z,{groupId:"turbomodule-specs",defaultValue:i.Z.defaultJavaScriptSpecLanguages,values:i.Z.javaScriptSpecLanguages,mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"typescript",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-typescript",metastring:'title="NativeSampleModule.ts"',title:'"NativeSampleModule.ts"'}),"   // ...\n   readonly cubicRoot: (input: string) => number;\n   // ..\n"))),(0,a.kt)(o.Z,{value:"flow",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-js",metastring:'title="NativeSampleModule.js"',title:'"NativeSampleModule.js"'}),"   // ...\n   +cubicRoot: (input: string) => number;\n   // ..\n")))),(0,a.kt)("p",null,"Declare it in your ",(0,a.kt)("inlineCode",{parentName:"p"},"NativeSampleModule.h")," file and include the ",(0,a.kt)("inlineCode",{parentName:"p"},"Int64.h")," header file:"),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-cpp"}),'//...\n#include "Int64.h"\n//...\nint32_t cubicRoot(jsi::Runtime& rt, int64_t input);\n')),(0,a.kt)("p",null,"And implement it in ",(0,a.kt)("inlineCode",{parentName:"p"},"NativeSampleModule.cpp"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-cpp"}),"//...\n#include <cmath>\n//...\nint32_t NativeSampleModule::cubicRoot(jsi::Runtime& rt, int64_t input) {\n    return std::cbrt(input);\n}\n")),(0,a.kt)("p",null,"In your app you can call this new native function via:"),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-js"}),"<Section title=\"Cxx TurboModule\">\n  NativeSampleModule.cubicRoot(...) ={' '}\n  {JSON.stringify(\n    NativeSampleModule.cubicRoot('9223372036854775807'),\n  )}\n</Section>\n")),(0,a.kt)("p",null,"which should return ",(0,a.kt)("inlineCode",{parentName:"p"},"2097152"),"."),(0,a.kt)("h2",y({},{id:"any-custom-type"}),"Any custom type"),(0,a.kt)("p",null,"Similar to the example above you can now write custom ",(0,a.kt)("inlineCode",{parentName:"p"},"bridging")," functionality for any custom C++ type you want to expose to react-native. E.g., you can add support for ",(0,a.kt)("inlineCode",{parentName:"p"},"folly::StringPiece"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"QString"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"boost::filesystem::path"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"absl::optional")," or any other type you need to support in your C++ Turbo Native Modules."),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-cpp",metastring:'title="Path.h"',title:'"Path.h"'}),"#pragma once\n\n#include <react/bridging/Bridging.h>\n#include <boost/filesystem.hpp>\n\nnamespace facebook::react {\n\ntemplate<>\nstruct Bridging<boost::filesystem::path> {\n  static boost::filesystem::path fromJs(jsi::Runtime& rt, const std::string& value) { // auto-bridge from jsi::String to std::string\n    return boost::filesystem::path(value);\n  }\n\n  static jsi::String toJs(jsi::Runtime& rt, boost::filesystem::path value) {\n    return bridging::toJs(rt, value.string());\n  }\n};\n\n} // namespace facebook::react\n")),(0,a.kt)("h2",y({},{id:"custom-structs"}),"Custom structs"),(0,a.kt)("p",null,"You can use the same approach for you custom types in JavaScript such as this one:"),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-js"}),"export type CustomType = {\n  key: string,\n  enabled: boolean,\n  time?: number,\n};\n")),(0,a.kt)("p",null,"which can be exposed to your C++ Turbo Native Module via"),(0,a.kt)(r.Z,{groupId:"turbomodule-specs",defaultValue:i.Z.defaultJavaScriptSpecLanguages,values:i.Z.javaScriptSpecLanguages,mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"typescript",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-typescript",metastring:'title="NativeSampleModule.ts"',title:'"NativeSampleModule.ts"'}),"   // ...\n   readonly passCustomType: (input: CustomType) => CustomType;\n   // ..\n"))),(0,a.kt)(o.Z,{value:"flow",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-js",metastring:'title="NativeSampleModule.js"',title:'"NativeSampleModule.js"'}),"   // ...\n   +passCustomType: (input: CustomType) => CustomType;\n   // ..\n")))),(0,a.kt)("h3",y({},{id:"manually-typed"}),"Manually typed"),(0,a.kt)("p",null,"To use this custom type in C++, you need to define your custom Struct and ",(0,a.kt)("inlineCode",{parentName:"p"},"bridging")," function e.g., directly in ",(0,a.kt)("inlineCode",{parentName:"p"},"NativeSampleModule.h"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-cpp"}),'struct CustomType {\n  std::string key;\n  bool enabled;\n  std::optional<int32_t> time;\n};\n\ntemplate <>\nstruct Bridging<CustomType> {\n  static CustomType fromJs(\n      jsi::Runtime &rt,\n      const jsi::Object &value,\n      const std::shared_ptr<CallInvoker> &jsInvoker) {\n    return CustomType{\n        bridging::fromJs<std::string>(\n            rt, value.getProperty(rt, "key"), jsInvoker),\n        bridging::fromJs<bool>(\n            rt, value.getProperty(rt, "enabled"), jsInvoker),\n        bridging::fromJs<std::optional<int32_t>>(\n            rt, value.getProperty(rt, "time"), jsInvoker)};\n  }\n\n  static jsi::Object toJs(jsi::Runtime &rt, const CustomType &value) {\n    auto result = facebook::jsi::Object(rt);\n    result.setProperty(rt, "key", bridging::toJs(rt, value.key));\n    result.setProperty(rt, "enabled", bridging::toJs(rt, value.enabled));\n    if (value.time) {\n      result.setProperty(rt, "time", bridging::toJs(rt, value.time.value()));\n    }\n    return result;\n  }\n};\n')),(0,a.kt)("p",null,"Declare it in your ",(0,a.kt)("inlineCode",{parentName:"p"},"NativeSampleModule.h")," file:"),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-cpp"}),"  CustomType passCustomType(jsi::Runtime& rt, CustomType input);\n")),(0,a.kt)("p",null,"Implement it in ",(0,a.kt)("inlineCode",{parentName:"p"},"NativeSampleModule.cpp"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-cpp"}),'CustomType NativeSampleModule::passCustomType(jsi::Runtime& rt, CustomType input) {\n  input.key = "1909";\n  input.enabled = !input.enabled;\n  input.time = 42;\n  return input;\n}\n')),(0,a.kt)("p",null,"In your app you can call this new native function via:"),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-js"}),"<Section title=\"Cxx TurboModule\">\n  NativeSampleModule.passCustomType(...) ={' '}\n  {JSON.stringify(\n    NativeSampleModule.passCustomType({\n      key: '123',\n      enabled: true,\n      time: undefined,\n    }),\n  )}\n</Section>\n")),(0,a.kt)("p",null,"which should return ",(0,a.kt)("inlineCode",{parentName:"p"},'{"key":"1909","enabled":false","time":42}'),"."),(0,a.kt)("p",null,"This works - but is quite complex."),(0,a.kt)("h3",y({},{id:"struct-generator"}),"Struct generator"),(0,a.kt)("p",null,(0,a.kt)("a",y({parentName:"p"},{href:"/docs/the-new-architecture/pillars-codegen"}),(0,a.kt)("strong",{parentName:"a"},"Codegen"))," for C++ Turbo Native Modules does support struct generators, so you can simplify the code above in ",(0,a.kt)("inlineCode",{parentName:"p"},"NativeSampleModule.h")," to:"),(0,a.kt)("pre",null,(0,a.kt)("code",y({parentName:"pre"},{className:"language-cpp"}),"using CustomType = NativeSampleModuleBaseCustomType<std::string, bool, std::optional<int32_t>>;\ntemplate <>\nstruct Bridging<CustomType>\n    : NativeSampleModuleBaseCustomTypeBridging<std::string, bool, std::optional<int32_t>> {};\n")),(0,a.kt)("p",null,"With ",(0,a.kt)("inlineCode",{parentName:"p"},"using CustomType")," you declare a name for your concrete struct."),(0,a.kt)("h4",y({},{id:"member-types"}),"Member types"),(0,a.kt)("p",null,"With ",(0,a.kt)("inlineCode",{parentName:"p"},"std::string, bool, std::optional<int32_t>")," you define the property types of the struct members in the order they were defined in your JavaScript spec. The ",(0,a.kt)("strong",{parentName:"p"},"order matters"),". The ",(0,a.kt)("em",{parentName:"p"},"1st")," template argument refers to the ",(0,a.kt)("em",{parentName:"p"},"1st")," data type of the struct, and so forth."),(0,a.kt)("p",null,"Without any custom conversion functions:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"you can only ",(0,a.kt)("inlineCode",{parentName:"li"},"bridge")," a JS string to a ",(0,a.kt)("a",y({parentName:"li"},{href:"https://github.com/facebook/react-native/blob/main/ReactCommon/react/bridging/AString.h"}),"std::string")," and a JS boolean to a ",(0,a.kt)("a",y({parentName:"li"},{href:"https://github.com/facebook/react-native/blob/main/ReactCommon/react/bridging/Bool.h"}),"bool"),"."),(0,a.kt)("li",{parentName:"ul"},"but you can choose different JS ",(0,a.kt)("inlineCode",{parentName:"li"},"number")," ",(0,a.kt)("a",y({parentName:"li"},{href:"https://github.com/facebook/react-native/blob/main/ReactCommon/react/bridging/Number.h"}),"representations in C++"),".")),(0,a.kt)("h4",y({},{id:"base-class"}),"Base class"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"NativeSampleModuleBaseCustomType")," is an auto-generated template in your ",(0,a.kt)("inlineCode",{parentName:"p"},"AppSpecsJSI.h")," which name is generated by:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"NativeSampleModule")," (name of C++ Turbo Native Module in the JavaScript spec) +"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"Base")," (constant) +"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"CustomType")," (name of type in the JavaScript spec)")),(0,a.kt)("p",null,"The same naming schema applies to the necessary ",(0,a.kt)("inlineCode",{parentName:"p"},"Bridging")," struct which is defined via ",(0,a.kt)("inlineCode",{parentName:"p"},"struct Bridging<CustomType>"),"."))}C.isMDXComponent=!0}}]);